"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  PubSubDriver: () => PubSubDriver
});
module.exports = __toCommonJS(src_exports);
var import_listener = require("@flatfile/listener");
var import_api = __toESM(require("@flatfile/api"));
var import_pubnub = __toESM(require("pubnub"));
var import_utils_debugger = require("@flatfile/utils-debugger");
var import_axios = __toESM(require("axios"));
var PubSubDriver = class extends import_listener.EventDriver {
  constructor(scope) {
    super();
    this.scope = scope;
    this.events = /* @__PURE__ */ new Map();
  }
  async start(immediate = false) {
    (0, import_utils_debugger.axiosInterceptor)(import_axios.default);
    return new Promise((resolve, reject) => {
      const connect = async () => {
        if (!this.scope) {
          throw new Error(
            "scope is required (must be an environment or space id)"
          );
        }
        const getToken = async () => {
          const { data: token2 } = await import_api.default.events.getEventToken({
            scope: this.scope
          });
          return token2;
        };
        const token = await getToken();
        const pubnub = new import_pubnub.default({
          subscribeKey: token.subscribeKey,
          subscribeRequestTimeout: 3e4,
          userId: token.accountId,
          restore: true
        });
        this.pubnub = pubnub;
        pubnub.setToken(token.token);
        pubnub.addListener({
          status: (event) => {
            if (event.category === "PNConnectedCategory" && event.operation === "PNSubscribeOperation") {
              import_utils_debugger.Debugger.logSuccess(
                `Connected to event stream for scope ${this.scope}`
              );
              resolve(pubnub);
            }
            if ("error" in event && event.error) {
              import_utils_debugger.Debugger.logError(
                event.errorData?.message,
                event.operation,
                event.category
              );
              if (event.category === "PNAccessDeniedCategory") {
                import_utils_debugger.Debugger.logInfo("Attempting to reauthenticate...");
                getToken().then((token2) => {
                  pubnub.setToken(token2.token);
                  pubnub.reconnect();
                  import_utils_debugger.Debugger.logSuccess("Reconnected");
                });
              }
            }
          },
          message: async (event) => {
            try {
              const e = typeof event.message === "string" ? JSON.parse(event.message) : event.message;
              if (this.events.get(e.id)) {
                return;
              }
              this.events.set(e.id, true);
              const listeners = this._handler?.getListeners(e, true);
              if (listeners?.length) {
                import_utils_debugger.Debugger.logEvent(e);
                listeners.forEach(({ query, filter }) => {
                  import_utils_debugger.Debugger.logEventSubscriber(query, filter);
                });
                await this._handler?.dispatchEvent(e);
              }
            } catch (e) {
              console.error(e);
            }
          }
        });
        const scopeSignature = this.scope.includes("env") ? "environment" : "space";
        pubnub.subscribe({ channels: [scopeSignature + "." + this.scope] });
      };
      connect().catch(reject).finally(() => {
        if (immediate) {
          resolve(this.pubnub);
        }
      });
    });
  }
  /**
   * Shutdown the pubnub stream
   */
  shutdown() {
    this.pubnub?.unsubscribeAll();
    this.pubnub?.stop();
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  PubSubDriver
});
