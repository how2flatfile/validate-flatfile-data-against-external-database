{"version":3,"file":"index.mjs","sources":["../../cross-env-config/dist/index.mjs","../src/events/authenticated.client.ts","../src/utils/helpers.ts","../src/events/cache.ts","../src/events/flatfile.event.ts","../src/events/glob.match.ts","../src/events/event.handler.ts","../src/flatfile.listener.ts","../src/event-drivers/_EventDriver.ts","../src/event-drivers/Browser.ts","../src/event-drivers/FlatfileVirtualMachine.ts","../src/index.ts"],"sourcesContent":["// src/index.ts\nvar CrossEnvConfig = class {\n  /**\n   * Get a config value from either the environment or any registry overrides\n   * @param prop\n   */\n  static get(prop) {\n    return this.safeEnvLookup(prop);\n  }\n  /**\n   * Set a value explicitly\n   *\n   * @param key\n   * @param value\n   */\n  static set(key, value) {\n    return this._overrides.set(key, value);\n  }\n  /**\n   * Alias a key to another key if helpful. This is useful if you have different naming\n   * constructs for different environments.\n   *\n   * @param from\n   * @param to\n   */\n  static alias(from, to) {\n    return this._aliases.set(from, to);\n  }\n  /**\n   * Helpful if you've decided to store settings in another object and want to\n   * make that available here. For example in client-side implementations you may reserve\n   * a window.FLATFILE_CONFIG object to store settings.\n   *\n   * @param obj\n   */\n  static attachConfigRegistry(obj) {\n    this._registry = obj;\n  }\n  /**\n   * Use this to provide an override getter for config values. This is useful\n   * if you need to dynamically look up values. Overrides will still take precedence.\n   *\n   * @param cb\n   */\n  static attachConfigFactory(cb) {\n    this._factory = cb;\n  }\n  static reset() {\n    this._overrides = /* @__PURE__ */ new Map();\n    this._registry = void 0;\n    this._factory = void 0;\n  }\n  /**\n   * Internal function for traversing the possible environment sources for a value\n   *\n   * @param prop\n   * @private\n   */\n  static safeEnvLookup(prop) {\n    let values = [];\n    if (this._overrides.get(prop)) {\n      values.push(this._overrides.get(prop));\n    }\n    if (typeof this._registry === \"object\") {\n      values.push(this._registry[prop]);\n    }\n    if (typeof this._factory === \"function\") {\n      values.push(this._factory(prop));\n    }\n    if (typeof process === \"object\" && typeof process.env === \"object\") {\n      values.push(process.env[prop]);\n    }\n    values.push(...this.checkForBrowserVariables(prop));\n    const foundValue = values.find((v) => v !== void 0);\n    if (foundValue !== void 0) {\n      return foundValue;\n    }\n    const alias = this._aliases.get(prop);\n    if (alias) {\n      return this.safeEnvLookup(alias);\n    }\n    return void 0;\n  }\n  /**\n   * Internal function for checking for stored variables in a browser-like environment\n   *\n   * @param prop\n   * @private\n   */\n  static checkForBrowserVariables(prop) {\n    let values = [];\n    if (typeof window === \"object\") {\n      const windowValue = window[`CROSSENV_${prop}`];\n      if (windowValue !== void 0) {\n        values.push(windowValue);\n      }\n      if (typeof sessionStorage === \"object\") {\n        const storedValue = sessionStorage.getItem(`CROSSENV_${prop}`);\n        if (storedValue !== null) {\n          values.push(storedValue);\n        }\n      }\n    }\n    return values;\n  }\n};\nCrossEnvConfig._overrides = /* @__PURE__ */ new Map();\n/**\n * A map of aliases that can be used to look up config values.\n *\n * @private\n */\nCrossEnvConfig._aliases = /* @__PURE__ */ new Map();\nexport {\n  CrossEnvConfig\n};\n","import { CrossEnvConfig } from '@flatfile/cross-env-config'\nimport fetch from 'cross-fetch'\nimport { ensureSingleTrailingSlash } from '../utils/helpers'\n\nexport class AuthenticatedClient {\n  public _accessToken?: string\n  public _apiUrl?: string\n\n  constructor(accessToken?: string, apiUrl?: string) {\n    const FLATFILE_API_URL =\n      CrossEnvConfig.get('AGENT_INTERNAL_URL') || 'http://localhost:3000'\n    const bearerToken = CrossEnvConfig.get('FLATFILE_BEARER_TOKEN')\n\n    this._accessToken = accessToken || bearerToken || '...'\n\n    this._apiUrl =\n      apiUrl || FLATFILE_API_URL\n        ? ensureSingleTrailingSlash(apiUrl || FLATFILE_API_URL)\n        : undefined\n  }\n\n  async fetch(url: string, options?: any) {\n    const headers = {\n      Authorization: `Bearer ${this._accessToken}`,\n      'x-disable-hooks': 'true',\n      'Content-Type': 'application/json',\n      ...options?.headers,\n    }\n\n    const fetchUrl = this._apiUrl + url\n\n    const fetchOptions = {\n      method: options?.method || 'GET',\n      headers,\n      body: options?.data,\n    }\n\n    try {\n      const response = await fetch(fetchUrl, fetchOptions)\n\n      if (response.status >= 200 && response.status <= 399) {\n        const contentType = response.headers.get('content-type')\n        if (contentType && contentType.includes('application/json')) {\n          const responseData = (await response.json()) as { data: any }\n          return responseData.data\n        } else {\n          const responseData = await response.text()\n          return responseData\n        }\n      } else {\n        throw new Error(`HTTP error! Status: ${response.status}`)\n      }\n    } catch (err) {\n      console.log('event.fetch error: ', err)\n    }\n  }\n\n  /**\n   *\n   * @deprecated use @flatfile/cross-env-config instead\n   */\n  public setVariables({\n    accessToken,\n    apiUrl,\n  }: {\n    accessToken?: string\n    apiUrl?: string\n  }) {\n    this._accessToken = accessToken\n    this._apiUrl = apiUrl\n  }\n}\n","export const ensureSingleTrailingSlash = (url: string) => {\n  // Remove all trailing slashes\n  while (url.endsWith('/')) {\n    url = url.slice(0, -1)\n  }\n\n  // Append one slash\n  return url + '/'\n}\n","export class EventCache {\n  private eventCache: Map<any, any> = new Map()\n\n  async init<T>(key: string, callback: () => Promise<T>): Promise<T> {\n    if (this.eventCache.get(key)) {\n      return this.eventCache.get(key)\n    } else {\n      const result = await callback()\n      this.eventCache.set(key, result)\n      return result\n    }\n  }\n\n  async set<T>(key: string, callback: () => Promise<T>): Promise<T> {\n    if (this.eventCache.get(key)) {\n      const result = await callback()\n      this.eventCache.set(key, result)\n      return result\n    } else {\n      throw new Error('Cache key not found')\n    }\n  }\n\n  get<T>(key: string): T {\n    if (this.eventCache.get(key)) {\n      return this.eventCache.get(key)\n    } else {\n      throw new Error('Cache key not found')\n    }\n  }\n\n  delete(key?: string | string[]): void {\n    if (!key) {\n      this.eventCache.clear()\n    } else if (this.eventCache.get(key)) {\n      if (Array.isArray(key)) {\n        key.forEach((k) => this.eventCache.delete(k))\n      } else {\n        this.eventCache.delete(key)\n      }\n    } else {\n      throw new Error('Cache key not found')\n    }\n  }\n}\n","import { AuthenticatedClient } from './authenticated.client'\n\nimport { Event, RecordsWithLinks } from '@flatfile/api/api'\nimport { EventCache } from './cache'\n\nimport pako from 'pako'\n\ntype GetDataOptions = { [key: string]: any }\ninterface GetData extends Function {\n  (options?: GetDataOptions): Promise<any>\n  then<TResult1 = any, TResult2 = any>(\n    onfulfilled?: ((value: any) => TResult1 | PromiseLike<TResult1>) | null,\n    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null\n  ): Promise<TResult1 | TResult2>\n}\n\nexport class FlatfileEvent extends AuthenticatedClient {\n  /**\n   * Event ID from the API\n   *\n   * @example us0_ev_82hgidh9skd\n   * @readonly\n   *\n   */\n  public readonly id?: string\n\n  /**\n   * Topic the event was produced on\n   *\n   * @example workbook:created\n   * @readonly\n   */\n  public readonly topic: string\n  public readonly domain: string\n  public readonly target: string\n  public readonly origin: object\n  public readonly action: string\n  public readonly context: any\n  public readonly payload: any\n  public readonly cache: EventCache\n  public readonly namespace: string[]\n  public readonly createdAt?: Date\n  /**\n   * Fetch record data from Flatfile API via the event's dataUrl\n   *\n   * @async\n   * @param {object} options\n   * @returns {Promise<any>} JSON\n   */\n  public data: GetData\n\n  constructor(\n    public readonly src: Event,\n    accessToken?: string,\n    apiUrl?: string\n  ) {\n    super(accessToken, apiUrl)\n    this.cache = new EventCache()\n    this.domain = src.domain\n    this.topic = src.topic\n    this.context = src.context // -> [us0_acc_ihjh8943h9w, space_id, workbook_id]\n    this.payload = src.payload\n    this.target = src.target || ''\n    this.origin = src.origin || {}\n    this.action = src.context?.actionName || ''\n    this.namespace = src.namespaces || []\n    this.createdAt = src.createdAt || undefined\n\n    const data = async (options?: GetDataOptions): Promise<any> =>\n      this.fetchData(options)\n\n    data.then = <TResult1 = any, TResult2 = any>(\n      onfulfilled?: ((value: any) => TResult1 | PromiseLike<TResult1>) | null,\n      onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null\n    ): Promise<TResult1 | TResult2> => {\n      return this.data().then(onfulfilled, onrejected)\n    }\n\n    this.data = data\n  }\n\n  /**\n   * Should return either event body if expanded already or fetch data from the\n   * signed dataURL\n   */\n  private async fetchData(options?: GetDataOptions): Promise<any> {\n    const dataUrl = new URLSearchParams(this.src.dataUrl)\n    if (options) {\n      for (const [key, values] of Object.entries(options)) {\n        if (Array.isArray(values)) {\n          for (const value of values) {\n            dataUrl.append(key, value)\n          }\n        } else {\n          dataUrl.append(key, values)\n        }\n      }\n    }\n    const decodedURL = decodeURIComponent(dataUrl.toString())\n    if (decodedURL) {\n      return this.fetch(decodedURL)\n    } else {\n      return this.payload\n    }\n  }\n\n  private afterAllCallbacks: Map<any, any> = new Map()\n  afterAll<T>(callback: () => T, cacheKey?: string): void {\n    const key = cacheKey || callback.toString()\n    if (!this.afterAllCallbacks.get(key)) {\n      this.afterAllCallbacks.set(key, callback)\n    }\n  }\n\n  async update(records: RecordsWithLinks, compressRequestBody = true) {\n    if (!this.src.dataUrl) {\n      throw new Error('Cannot set data on an event without a dataUrl')\n    }\n\n    // TODO: do we need to remove source from the messages array?\n    records.map((record) => {\n      record.messages?.map((message) => {\n        delete message.source\n      })\n    })\n\n    const data = compressRequestBody\n      ? pako.gzip(JSON.stringify(records))\n      : records\n\n    const headers = compressRequestBody\n      ? { 'Content-Encoding': 'gzip', 'Content-Length': data.length.toString() }\n      : {}\n\n    await this.fetch(this.src.dataUrl, {\n      method: 'PUT',\n      headers: headers,\n      data,\n    })\n  }\n\n  /**\n   * Fetch the Secrets as indicated by this event context\n   *\n   * @param key - The name of the secret to fetch\n   * @param options - (Optional) environmentId and spaceId to override event context\n   *\n   * @returns The value of the secret (usually a credential or token)\n   */\n  async secrets(\n    key: string,\n    options?: { environmentId?: string; spaceId?: string }\n  ) {\n    // Allow options overrides, then take from context, else are absent\n    const environmentId =\n      options?.environmentId || this.context.environmentId || ''\n    const spaceId = options?.spaceId || this.context.spaceId || ''\n\n    if (!environmentId) {\n      throw new Error('environmentId is required to fetch secrets')\n    }\n\n    let getSecrets = `v1/secrets?environmentId=${environmentId}`\n\n    if (spaceId) {\n      getSecrets += `&spaceId=${spaceId}`\n    }\n\n    const secretCacheKey = `secrets:${environmentId}${spaceId && `:${spaceId}`}`\n\n    const secrets = await this.cache.init(secretCacheKey, async () => {\n      const secretsResponse = await this.fetch(getSecrets)\n      const SecretMap = new Map<string, string>()\n      secretsResponse?.forEach((secret: { name: string; value: string }) => {\n        SecretMap.set(secret.name, secret.value)\n      })\n      return SecretMap\n    })\n\n    const value = secrets.get(key)\n    if (!value) {\n      throw new Error(`Secret ${key} not found`)\n    }\n    return value\n  }\n}\n\nexport type EventCallback = (evt: FlatfileEvent) => void | Promise<void>\n","import { Arrayable } from './event.handler'\nimport wildMatch from 'wildcard-match'\nimport flat from 'flat'\n\n/**\n * Glob style matching of a value\n *\n * @param val\n * @param filter\n */\nexport function glob(val: any, filter: string | string[]): boolean {\n  if (!val || typeof val !== 'string') {\n    return false\n  }\n  return wildMatch(filter || '**', ':')(val)\n}\n\n/**\n * Glob style matching of values in an object\n *\n * @param object\n * @param filterObject\n */\nexport function objectMatches(\n  object: Record<string, any>,\n  filterObject: JSONPrimitive | FilterObj\n): boolean {\n  const cleanFilter: FilterObj =\n    !filterObject || typeof filterObject !== 'object'\n      ? { '**': filterObject }\n      : filterObject\n\n  if (typeof object !== 'object') {\n    throw new Error('You cannot filter a non-object')\n  }\n  let denied = false\n  const filter: FilterObj = flat(cleanFilter, { safe: true })\n  const flattened = flat(object, { safe: true }) as Record<\n    string,\n    JSONPrimitive\n  >\n\n  // all filters MUST resolve true\n  for (const keyPattern in filter) {\n    const keys = filterKeys(flattened, keyPattern)\n\n    const valuePattern = (\n      Array.isArray(filter[keyPattern])\n        ? filter[keyPattern]\n        : [filter[keyPattern]]\n    ) as JSONPrimitive[]\n\n    // only one filter must match\n    denied ||= !keys.some((key) => {\n      const value: JSONPrimitive = flattened[key]\n      return valuePattern.some((match) => globOrMatch(value, match))\n    })\n  }\n  return !denied\n}\n\n/**\n * Glob keys of an object and return the narrowed set\n *\n * @param object\n * @param glob\n */\nfunction filterKeys<T extends Record<string, any>>(\n  object: Record<string, any>,\n  glob: string\n): Array<keyof T> {\n  glob = glob.includes('*') || glob.includes('.') ? glob : `**.${glob}`\n  const matcher = wildMatch(glob, '.')\n  return Object.keys(object).filter((key) => matcher(key))\n}\n\nfunction globOrMatch(\n  val: Arrayable<JSONPrimitive>,\n  filter: JSONPrimitive\n): boolean {\n  if (val === undefined || val === null) {\n    return filter === null\n  }\n  if (Array.isArray(val)) {\n    return val.some((v) => globOrMatch(v, filter))\n  }\n  if (typeof filter === 'string') {\n    return glob(val.toString(), filter)\n  }\n\n  // otherwise do a simple comparison\n  return val === filter\n}\n\ntype JSONPrimitive = string | number | boolean | null\n\ntype FilterObj = Record<\n  string,\n  Arrayable<JSONPrimitive> | Record<string, Arrayable<JSONPrimitive>>\n>\n","import { AuthenticatedClient } from './authenticated.client'\nimport { EventCallback, FlatfileEvent } from './flatfile.event'\nimport { glob, objectMatches } from './glob.match'\nimport type { Flatfile } from '@flatfile/api'\n\n/**\n * EventHandler is a Flatfile flavored implementation of EventTarget\n */\nexport class EventHandler extends AuthenticatedClient {\n  /**\n   * Apply a filter to the values of an event\n   */\n  public readonly filterQuery?: EventFilter\n\n  /**\n   * Cache of registered listeners on this instance\n   * @private\n   */\n  protected listeners: [string | string[], EventFilter, EventCallback][] = []\n\n  constructor(filter?: EventFilter, accessToken?: string, apiUrl?: string) {\n    super(accessToken, apiUrl)\n    if (filter) {\n      this.filterQuery = filter\n    }\n  }\n\n  /**\n   * Cache of registered child nodes for this listener. These nodes will\n   * only receive events that pass the parent filter.\n   *\n   * @private\n   */\n  protected nodes: EventHandler[] = []\n\n  /**\n   * Register a subscriber for events that match this path\n   */\n  on(query: Arrayable<string>, callback: EventCallback): this\n  on(\n    query: Arrayable<string>,\n    filter: EventFilter,\n    callback: EventCallback\n  ): this\n  on(\n    query: Arrayable<string>,\n    ...rest: [EventCallback] | [EventFilter, EventCallback]\n  ): this {\n    let filter: EventFilter = {}\n    const callback: EventCallback = rest.pop() as EventCallback\n\n    if (rest.length) {\n      filter = rest.shift() as EventFilter\n    }\n\n    this.listeners.push([query, filter, callback])\n\n    return this\n  }\n\n  off(query: Arrayable<string>, callback: EventCallback): this\n  off(\n    query: Arrayable<string>,\n    filter: EventFilter,\n    callback: EventCallback\n  ): this\n\n  // Implementation\n  off(\n    query: Arrayable<string>,\n    filterOrCallback: EventFilter | EventCallback,\n    maybeCallback?: EventCallback\n  ): this {\n    let filter: EventFilter | undefined = undefined\n    let callback: EventCallback\n\n    if (typeof filterOrCallback === 'function') {\n      callback = filterOrCallback as EventCallback\n    } else {\n      filter = filterOrCallback\n      callback = maybeCallback!\n    }\n\n    this.listeners = this.listeners.filter(\n      ([listenerQuery, listenerFilter, listenerCallback]) => {\n        // Normalize query for comparison\n        const normalizedListenerQuery = Array.isArray(listenerQuery)\n          ? listenerQuery\n          : [listenerQuery]\n        const normalizedQuery = Array.isArray(query) ? query : [query]\n\n        // Match checks\n        const isQueryMatch =\n          JSON.stringify(normalizedListenerQuery) ===\n          JSON.stringify(normalizedQuery)\n        const isCallbackMatch = listenerCallback === callback\n        const isFilterMatch = filter\n          ? JSON.stringify(listenerFilter) === JSON.stringify(filter)\n          : true\n\n        // Keep the listener if it doesn't match all criteria for removal\n        return !(isQueryMatch && isCallbackMatch && isFilterMatch)\n      }\n    )\n\n    return this\n  }\n\n  /**\n   * Add child nodes to send this event to as well\n   *\n   * @param node\n   */\n  addNode(node: EventHandler): this {\n    this.nodes.push(node)\n    return this\n  }\n\n  /**\n   * Dispatch an event and resolve the promise once it has completed (or\n   * errored\n   *\n   * @todo - is there a right order in which to resolve event listeners?\n   *   Should it matter?\n   *\n   * @param event\n   */\n  async dispatchEvent(\n    event: FlatfileEvent | Flatfile.Event | any\n  ): Promise<void> {\n    if (!event) return\n    const eventPayload = event.src || event\n\n    event = new FlatfileEvent(eventPayload, this._accessToken, this._apiUrl)\n\n    await this.trigger(event, true)\n\n    for (const [_key, cb] of event.afterAllCallbacks) {\n      await cb(event)\n    }\n\n    event.cache.delete()\n  }\n\n  /**\n   * @deprecated legacy shim for receiving events from the VM layer\n   * @alias dispatchEvent\n   * @param event\n   */\n  async routeEvent(event: Flatfile.Event) {\n    return this.dispatchEvent(event)\n  }\n\n  /**\n   * Actually trigger the event listeners on this particular target\n   *\n   * @note It is safer for now to run this in series to avoid IO locks and\n   *       potential race conditions and uncaught errors\n   *\n   * @param event\n   * @param recursive\n   */\n  async trigger(\n    event: FlatfileEvent,\n    recursive: boolean = false\n  ): Promise<void> {\n    const listeners = this.getListeners(event, recursive)\n    for (const cb of listeners) {\n      await cb.callback(event)\n    }\n  }\n\n  /**\n   * Get any listeners from this target subscribing to this event\n   *\n   * @param event\n   * @param recursive\n   */\n  public getListeners(\n    event: FlatfileEvent,\n    recursive: boolean = false\n  ): Listener[] {\n    // never return any listeners if the event doesn't match the filter\n    // event recursion should not occur either\n    if (!this.matchEvent(event, this.filterQuery)) {\n      return []\n    }\n\n    // look at listeners registered here\n    const listeners = this.listeners\n      .filter(([query, filter]) => {\n        const globbed = glob(event.topic, query)\n        const matched = this.matchEvent(event, filter)\n        return globbed && matched\n      })\n      .map(([query, filter, callback]) => ({ query, filter, callback }))\n\n    return !recursive\n      ? listeners\n      : [\n          ...listeners,\n          ...this.nodes.flatMap((n) => n.getListeners(event, true)),\n        ]\n  }\n\n  /**\n   * Attach more event listeners using a callback function. Used most\n   * frequently for plugins.\n   *\n   * @param fn\n   */\n  use(fn: (handler: this) => void): this {\n    fn(this)\n    return this\n  }\n\n  /**\n   * Filter an event out based on glob filter object\n   *\n   * @param event\n   * @param filter\n   */\n  public matchEvent(\n    event: FlatfileEvent,\n    filter: EventFilter | undefined\n  ): boolean {\n    return filter ? objectMatches(event, filter) : true\n  }\n\n  public detach() {\n    // Clear the listeners array\n    this.listeners = []\n\n    // Optionally, also detach all child nodes\n    this.nodes.forEach((node) => node.detach())\n    this.nodes = []\n\n    // Additional cleanup logic, if necessary\n    // e.g., Unsubscribe from external services or event sources\n  }\n}\n\nexport type EventFilter = Record<\n  string,\n  any\n  // TODO: Open question - 1 level nested object. Do we want/need more than that?\n  // Arrayable<string> | Record<string, Arrayable<string>>\n>\n\nexport type Arrayable<T> = T | Array<T>\nexport type Listener = {\n  query: string | string[]\n  filter: any\n  callback: EventCallback\n}\n\n// Utility function to compare queries/filters\nfunction isEqual(a: any, b: any): boolean {\n  // Implement comparison logic based on your application's needs\n  // This could be as simple as JSON.stringify(a) === JSON.stringify(b) for shallow comparison\n  // Or more complex deep comparison logic for nested objects\n  return JSON.stringify(a) === JSON.stringify(b)\n}\n","/**\n * The Flatfile Listener\n *\n * The Flatfile PubSub Client is just a simple event subscriber. It can\n * receive events from any PubSub driver. The default drivers are:\n *\n * - Webhook    (for simply processing events sent to URL)\n * - Websocket  (for subscribing real time on an HTTP2 connection)\n * - Serverless (for stateless invocations via AWS Lambda or similar)\n *\n * Once an event is received, it is routed to any awaiting listeners which\n * are added with `addEventListener()` or its alias `on()`.\n *\n * Flatfile events follow a standard structure and event listeners can use\n * any of the following syntaxes to react to events within Flatfile.\n *\n * // listen to an event\n * addEventListener('entity:topic')\n *\n * // listen to an event on a specific namespace\n * addEventListener('entity:topic@namespace')\n *\n * // listen to a specific context on a namespace\n * addEventListener('entity:topic@namespace?context=us_sp_89234oihsdo')\n *\n * // filter by any\n * addEventListener('entity:topic@namespace?')\n *\n */\n\nimport { EventFilter, EventHandler } from './events'\nimport { EventDriver } from './event-drivers'\n\nexport class FlatfileListener extends EventHandler {\n  /**\n   * Subscribe to events only within a certain namespace.\n   *\n   * @param namespace\n   * @param cb\n   */\n  namespace(namespaces: string | string[], cb?: SubFn<this>) {\n    return this.filter({ namespaces }, cb)\n  }\n\n  /**\n   * Filter by namespace\n   *\n   * @param filter\n   * @param cb\n   */\n  filter(filter: EventFilter, cb?: SubFn<this>): this {\n    const client = new (this.constructor as any)(filter)\n    this.addNode(client)\n    cb?.(client)\n    return client\n  }\n\n  /**\n   * Start subscribing to events\n   *\n   * @param cb\n   */\n  public static create<T extends FlatfileListener>(\n    this: Constructor<T>,\n    cb: SubFn<T>\n  ): T {\n    const client = new this()\n    cb(client)\n    return client\n  }\n\n  /**\n   * Mount this client using an acceptable Event Driver\n   */\n  mount(driver: EventDriver) {\n    driver.mountEventHandler(this)\n    return this\n  }\n\n  /**\n   * Unmount this client from the Event Driver\n   */\n  unmount(driver: EventDriver) {\n    driver.unmountEventHandler(this)\n    return this\n  }\n\n  fork() {\n    return new FlatfileListener()\n  }\n}\n\ntype SubFn<T extends FlatfileListener> = (client: T) => void\n\ntype Constructor<T> = { new (): T }\n","import { EventHandler } from '../events'\n\nexport abstract class EventDriver {\n  _handler?: EventHandler\n\n  public get handler(): EventHandler {\n    if (!this._handler) {\n      throw new Error('handler not registered yet')\n    }\n    return this._handler\n  }\n\n  /**\n   * Mount an event handler\n   *\n   * @param handler\n   */\n  mountEventHandler(handler: EventHandler): this {\n    this._handler = handler\n    return this\n  }\n\n  /**\n   * Unmount an event handler\n   *\n   * @param handler\n   */\n  unmountEventHandler(handler: EventHandler): this {\n    if (this._handler === handler) {\n      this._handler = undefined\n    }\n    return this\n  }\n\n  /**\n   * Dispatch an event\n   *\n   * @param e\n   */\n  dispatchEvent(e: any): this {\n    this.handler.dispatchEvent(e)\n    return this\n  }\n}\n","import { EventDriver } from './_EventDriver'\nimport { EventHandler } from '../events'\n\nexport class Browser extends EventDriver {\n  public _accessToken?: string\n  public _apiUrl?: string\n  public _environmentId?: string\n\n  constructor({\n    apiUrl,\n    accessToken,\n    environmentId,\n  }: {\n    apiUrl: string\n    accessToken: string\n    environmentId?: string\n    /**\n     * @deprecated\n     */\n    fetchApi: any\n  }) {\n    super()\n    this._apiUrl = apiUrl\n    this._accessToken = accessToken\n    this._environmentId = environmentId || ''\n  }\n\n  mountEventHandler(handler: EventHandler): this {\n    handler.setVariables({\n      accessToken: this._accessToken,\n      apiUrl: this._apiUrl,\n    })\n\n    this._handler = handler\n    return this\n  }\n}\n","import { EventDriver } from './_EventDriver'\nimport { EventHandler, FlatfileEvent } from '../events'\n\n/**\n * Flatfile's Virtual Machine is stateless / serverless. So when a new event\n * is handled, it will just call `handle(event)`.\n */\nexport class FlatfileVirtualMachine extends EventDriver {\n  /**\n   * This method is triggered from within the Flatfile Core VM Runner. This\n   * EventDriver does not have to listen for events because this method will\n   * be invoked as necessary.\n   *\n   * @param event\n   */\n\n  handle(event: FlatfileEvent) {\n    this.dispatchEvent(event)\n  }\n\n  mountEventHandler(handler: EventHandler): this {\n    this._handler = handler\n    return this\n  }\n}\n","import { FlatfileListener } from './flatfile.listener'\nexport * from './flatfile.listener'\nexport * from './event-drivers'\nexport * from './events'\n\n/**\n * Backwards compatibility\n */\nexport class Client extends FlatfileListener {}\n\nexport default FlatfileListener\n"],"names":["CrossEnvConfig","get","prop","this","safeEnvLookup","set","key","value","_overrides","alias","from","to","_aliases","attachConfigRegistry","obj","_registry","attachConfigFactory","cb","_factory","reset","Map","values","push","process","env","checkForBrowserVariables","foundValue","find","v","window","windowValue","sessionStorage","storedValue","getItem","_optionalChain","ops","lastAccessLHS","i","length","op","fn","args","call","undefined","AuthenticatedClient","constructor","accessToken","apiUrl","FLATFILE_API_URL","bearerToken","_accessToken","_apiUrl","url","endsWith","slice","ensureSingleTrailingSlash","fetch","options","headers","Authorization","_","fetchUrl","fetchOptions","method","_2","body","_3","data","response","status","contentType","includes","json","text","Error","err","console","log","setVariables","EventCache","prototype","__init","eventCache","init","callback","result","Array","isArray","forEach","k","delete","clear","FlatfileEvent","src","super","cache","domain","topic","context","payload","target","origin","action","actionName","namespace","namespaces","createdAt","async","fetchData","then","onfulfilled","onrejected","dataUrl","URLSearchParams","Object","entries","append","decodedURL","decodeURIComponent","toString","afterAllCallbacks","afterAll","cacheKey","update","records","compressRequestBody","map","record","messages","_4","_5","message","source","pako","gzip","JSON","stringify","secrets","environmentId","spaceId","_7","getSecrets","secretCacheKey","secretsResponse","SecretMap","_8","_9","secret","name","glob","val","filter","wildMatch","filterKeys","object","matcher","keys","globOrMatch","some","EventHandler","listeners","__init2","filterQuery","nodes","on","query","rest","pop","shift","off","filterOrCallback","maybeCallback","listenerQuery","listenerFilter","listenerCallback","normalizedListenerQuery","normalizedQuery","isQueryMatch","isCallbackMatch","isFilterMatch","addNode","node","dispatchEvent","event","eventPayload","trigger","_key","routeEvent","recursive","getListeners","matchEvent","globbed","matched","flatMap","n","use","filterObject","cleanFilter","denied","flat","safe","flattened","keyPattern","valuePattern","match","objectMatches","detach","FlatfileListener","client","create","mount","driver","mountEventHandler","unmount","unmountEventHandler","fork","EventDriver","handler","_handler","e","Browser","_environmentId","FlatfileVirtualMachine","handle","Client"],"mappings":"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"}